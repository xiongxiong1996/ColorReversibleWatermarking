% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%  Copyright (C) 2021  Duan Shaohua <smartJack10101@gmail.com>       %%%
% %%%  Copyright (C) 2021  Qian yuhan                                    %%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [local_map,T,alpha,error] = dq_get_localmap(hostImg,block_size,w_sequence,G,n_level)
% DQ_GET_LOCALMAP Summary of this function goes here
% 自适应获取嵌入直方图
%   Detailed explanation goes here
% 输入：hostImg----------嵌入水印后的图像（用于提取水印）
% 输入：local_map----------鲁棒水印嵌入图
% 输入：w_sequence----------水印序列
% 输入：G,----------G:阈值
% 输出：local_map----------鲁棒水印嵌入图
% 输出：T----------T:最大误差和
% 输出：alpha----------最后确定的参数，用于预测需要嵌入的块长度。
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%
% %%%   设定参数   %%%
% %%%%%%%%%%%%%%%%%%%%
w_len=size(w_sequence,2); % 获取水印序列的长度 1024
[n n]=size(hostImg);
local_map=zeros(n,n);
T=0;
% 对宿主图像进行分层
r_l=hostImg(:,:,1);
g_l=hostImg(:,:,2);
b_l=hostImg(:,:,3);
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%    生成R,G预测误差序列    %%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[perror_sequence_r] = dq_get_preErrorSequence(r_l,block_size,n_level); % R层分块预测误差和序列
[perror_sequence_g] = dq_get_preErrorSequence(g_l,block_size,n_level); % G层分块预测误差和序列
sequence_rg = abs(perror_sequence_r) + abs(perror_sequence_g); % R+G层分块预测误差和序列
[sorted_squence sorted_index] = sort(sequence_rg);% 排序并记录索引
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%    预嵌入生成local_map     %%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
bool=0; % 判断是否全部嵌入的bool变量，默认为0，即没有完全嵌入
alpha=1; % 设定预测长度参数alpha
a=0.1; % 设定预测长度参数的增量a
error=0; % 是否嵌入完毕
while bool==0 % 当没有完全嵌入的时候，进行迭代。直到满足水印全部嵌入
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        参数计算         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	alpha=alpha+a;
	w_len_p=floor(w_len*alpha);% 预测水印序列长度
	b_num_p=ceil(w_len_p/2);% 预测需要嵌入块的个数
    [n m]=size(sequence_rg);
    if b_num_p>=m
        error=1;
        break;
    end
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   确定预计偏移量B   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	T_min=0; % 最小的T值(最大误差和)
	for i=1:b_num_p
		if abs(perror_sequence_r(sorted_index(i)))>T_min
			T_min=abs(perror_sequence_r(sorted_index(i)));
		end
		if abs(perror_sequence_g(sorted_index(i)))>T_min
			T_min=abs(perror_sequence_g(sorted_index(i)));
		end
	end
	T=T_min;
	% M = ((block_size/2)-1)*(block_size-2); % 每个小块可嵌入序列的长度 3*6 =18
	% B_max=floor((T+G+M-1)/M); % 偏移量B的最大值
    M = block_size^2; % 每个小块可嵌入序列的长度 3*6 =18
	B_max=floor((T+G+M-1)/M); % 偏移量B的最大值
    
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       预嵌入      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% 如果所有水印序列可以完全嵌入，则bool为1，否则为0。继续进行迭代
	[bool,local_map]=dq_preEmbedingWatermarking(hostImg,block_size,w_sequence,sorted_index,b_num_p,T,G,n_level);
end
end
